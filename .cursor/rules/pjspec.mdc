## 機能仕様集（feature specs）

本ファイルは `pjrule` に記載されていた各機能の詳細仕様・実装注意・テスト手順を収録します。
主要項目: 投稿削除フロー、`DeletionQueue` 設計、GSI 推奨、テストフロー等。

### 投稿削除（共通方針 - deletePostsForAccount / deleteUserPosts）

- 目的
  - アカウント編集モーダル（即時削除）および定期実行（キュー処理）で同一の削除フローを実行する。

- 呼び出し先
  - `src/lib/delete-posts-for-account.ts` に共通実装を用意。`/api/accounts/{accountId}/delete-all` と Lambda のキュー処理の双方から呼ぶ。

- 入力
  - `userId` (必須)
  - `accountId` (必須)
  - `limit` (任意、既定は AppConfig `DELETION_BATCH_SIZE` または 100)

- 挙動（厳密手順）
  1. 取得: `fetchThreadsPosts({ userId, accountId, limit })` を実行して Threads 側の投稿IDリストを取得。API エラーは即時中断して例外を投げる。
  2. 削除 (API 優先): 取得した各 `postId` に対し、DB の存在有無に関わらず必ず Threads DELETE API を実行する。成功判定は既存の `src/pages/api/threads/delete-post.ts` と同一の基準を使う（404 や Facebook の `error_subcode===33` 等は「存在しない」扱いで成功とする）。
  3. DB 同期: 外部 DELETE が成功（または存在しない扱い）なら、その `postId` と `accountId` で `ScheduledPosts` を検索し、該当レコードがあれば **物理削除**（DeleteItemCommand）を行う。
  4. 完了判定: 指定件数を処理後、追加で `fetchThreadsPosts(..., limit:1)` を実行して 0 件なら `remaining=false` とし、キューがあれば削除・アカウント `status` を `active` に戻す。残件があれば `remaining=true` を返す。

- エラー・ログ方針
  - `ExecutionLogs`（`putLog`）へ永続化するのは下記のみ:
    - `fetchThreadsPosts` の致命的エラーで処理中断（`deletion_error`）
    - 外部 DELETE の致命的エラー（権限不足等）で処理中断（`deletion_error`）
    - 削除完了時の要約（`deletion_completed`）に `deletedCount` を含める
  - それ以外の詳細ログ（取得結果一覧、各 DELETE の HTTP レスポンス、マッピングサンプル等）は CloudWatch（console.info/warn/error）へ出力する。外部通知や大量ログは `ALLOW_DEBUG_EXEC_LOGS` で制御する。

- DB 操作順序の厳守
  - 必ず API → DB（Threads API を先に呼ぶ）で行うこと。DB を参照してから API を呼ぶことはしない。

- 戻り値
  - `{ deletedCount: number, remaining: boolean }`

- 実装補足
  - 物理削除ユーティリティ `src/lib/scheduled-posts-delete.ts` は物理削除指定（`physical=true`）時に失敗したら例外を throw し、呼び出し元で再試行できるようにすること。
  - `deletePostsForAccount` は即時削除（UI）とキュー削除（Lambda）両方から利用されるため冪等性に注意する。

### 裏画面（background）キュー作成ポリシー

- 裏画面実行（`mode === 'background'`）では、Threads API の取得が `0` 件でも **必ず** `DeletionQueue` にキューを作成する。目的は `ScheduledPosts` の DB 側クリーンアップを確実に行うため。
- キュー作成時の `last_processed_at`:
  - 背景キュー作成（mode==='background'）: `0` を設定
  - 即時削除に伴うキュー作成: 現在時刻を設定してワーカー側の即時再処理を回避

### ルール更新履歴（要約）

- 即時削除とキュー削除を統一（API 優先 → DB 物理削除）
- `last_processed_at` の扱いを明確化（即時=now / background=0）
- `dryrun` オプションは恒常化せずテストコードとして扱うことを推奨

### OAuth トークン方針（oauthAccessToken のみを使用）

- 方針: 今後は `oauthAccessToken` を正式トークンとし、`accessToken` は参照・フォールバックしない。
- 未設定または期限切れのトークンは自動処理（定期実行・手動バッチ含む）から除外し、アカウント状態を `reauth_required` に設定して UI 上で再認証を促す。

### アカウント編集モーダルの認証状態表示と解除機能

- 目的
  - アカウント編集モーダル（`SNSAccountModal`）内で、認可URLのコピーボタン横に簡潔な認証状態表示（ラベル）を置き、ユーザーがトークンの有無を一目で把握できるようにする。また、認証済であればワンクリックで認証解除（DB上のトークン削除）できるUIを提供する。

- 表示要件
  - 認証済み: `oauthAccessToken` または従来の `accessToken` の存在をもって「認証済み」と表示（緑のバッジ）。
  - 未認証: トークンが存在しない場合は「未認証」をグレーで表示。
  - モーダル表示時には可能な限り最新のDB状態を反映する。最短実装はモーダルに渡された `account` オブジェクト上のフィールドから判定する方法、推奨はモーダル表示時に `/api/threads-accounts?accountId=...` 等で最新値をフェッチして反映する。

- 解除（Deauthorize）ボタン挙動
  - 解除は確認ダイアログを表示したうえで実行する（同期的な confirm で可）。
  - クライアント側は `PATCH /api/threads-accounts` を呼び、ペイロードに `accountId` と `oauthAccessToken: ''` を含めることで DB 上のトークンを空にする。API 側は受けて UpdateItemCommand でフィールドを上書きできること。
  - 成功時のクライアント側処理:
    - UI 上のトークン関連 state (`accessToken`, `clientSecretMasked` 等) をクリアして「未認証」表示に切替える。
    - `reloadAccounts()` を呼んで一覧を更新する（必要に応じてモーダルを閉じる）。
    - ユーザー向けに成功メッセージ（alert など）を表示する。
  - 失敗時の処理:
    - エラーメッセージを alert 表示し、UI state は変更しない。

- セキュリティ・監査
  - トークン削除リクエストは認証済みユーザーであることを前提とし、サーバー側で `verifyUserFromRequest` を通すこと。
  - 監査のため、サーバー側でトークン削除操作（deauthorize）を ExecutionLogs に `action: 'deauthorize', initiatedBy: <userId>, accountId: <id>` として保存することを推奨。

- テスト
  - 単体テスト: モーダルの認証ラベルが `account` オブジェクトの `oauthAccessToken` 存在に応じて正しくレンダリングされること。
  - e2e/インテグレーション: 実際に PATCH を行って DB 上のトークンが消えることを確認し、UI が更新されることを検証する。スタブ/モックが利用可能な環境であれば PATCH の応答をモックして UI の分岐を確認する。


### トークン自動更新（auto-refresh）設計（概要）

- 目的: トークンの有効期限が近い場合に自動で更新（長期化）し、手動での再認証負荷を軽減する。
- 実装案（高レベル）:
  1. ThreadsAccounts に `oauthAccessToken`, `oauthAccessTokenExpiresAt`（Epoch 秒）を保持する。
  2. 定期ワーカー（例: `token-refresh` ジョブ）を導入し、`oauthAccessTokenExpiresAt - now <= REFRESH_THRESHOLD_SEC` のアカウントを検出して更新を試みる。
  3. 更新フロー: OAuth の long-lived 交換エンドポイント（`/access_token?grant_type=th_exchange_token` 等）を呼び、成功したら新しい `oauthAccessToken` と `expiresAt` を保存する。失敗（権限不足・拒否など）の場合は `status = 'reauth_required'` を設定し、ExecutionLogs に `oauth_refresh_failed` を記録する。
  4. セキュリティ: client_secret は Secrets Manager を用い、ログ出力ではトークン本体を決して出力しない（長さやマスクのみ可）。

- 運用パラメータ（環境変数）:
  - `TOKEN_REFRESH_THRESHOLD_SEC`（デフォルト: 60 * 60 * 24 = 1日）
  - `TOKEN_REFRESH_BATCH_SIZE`（1回あたりの更新対象件数）

- フォールバック: 自動更新に失敗した場合でも自動で `accessToken` を利用する等のフォールバックは行わない。再認証はユーザー操作で行う。

### アカウントステータスと UI 表示

- `ThreadsAccounts.status` に新しい値 `reauth_required` を追加。UI はこのステータスを検出して、アカウント一覧の状態欄に「要再認証」バッジと再認証ボタンを表示すること。
- ステータス変更はバッチ処理中に発生する可能性があるため、UI 側はリアルタイム更新を考慮する（ポーリングまたは WebSocket）。


---

### X（旧Twitter）統合仕様（追加）

- API ベース: `https://api.x.com/2`
- 認可方式: OAuth2.0（Authorization Code + PKCE）
- Token 取得: `POST https://api.x.com/2/oauth2/token`
- スコープ (初期): `tweet.write tweet.read users.read offline.access media.write`
- コールバック: `https://threadsbooster.jp/api/auth/x/callback`

方針メモ:
- Threads と同様の認証フロー（state + PKCE, リフレッシュ処理）を再利用する。
- clientSecret 等は当面 DB テーブルに平文で保存（Threads と同様）。将来的に Secrets Manager へ移行推奨。

重要（clientId/clientSecret とトークン取得の方針）:
- **必須方針**: X の `clientId` / `clientSecret` 系は **一切の環境変数フォールバックを行わない**。必ず対象のアカウントレコード（`x_accounts` テーブル内の該当 `ACCOUNT#<accountId>`）から読み出すこと。複数アカウント運用を前提に、ソースコードの可読性と運用の一貫性を保つためです。
- 実装要件:
  - 認可開始（`/api/x/authorize`）およびコールバック（`/api/x/callback`）は、該当アカウントの `clientId` / `clientSecret` を **DB から取得**することを前提に実装する。
  - DB に対象の `clientId` または `clientSecret` が存在しない場合は、処理は **即時エラー終了** とし、明確なエラーメッセージ（例: `client_id or client_secret not configured`）を返すこと。環境変数や AppConfig に値があっても X 用のクライアント情報のフォールバックには使わない。
- トークン取得/投稿時のトークン非存在時挙動:
  - 投稿処理（`/api/x/tweet` や定期ジョブ）は、対象アカウントから `oauthAccessToken`（または `accessToken` のフォールバックは不可とする）を取得できない場合、即時エラー（403 または 4xx）で終了してよい。
  - システムログ及び ExecutionLogs に該当の `accountId` とエラー詳細を記録すること（トークン自体や client_secret の値はログに出力しない）。


#### DynamoDB スキーマ案（要点・簡潔）

- テーブル名（環境変数で指定）
  - `TBL_X_ACCOUNTS`（例: `XAccounts`）
  - `TBL_X_SCHEDULED`（例: `XScheduledPosts`）

- `x_accounts`（ユーザごとの X アカウント）主要属性:
  - PK: `USER#${userId}` (S)
  - SK: `ACCOUNT#${accountId}` (S)
  - `accountId` (S)
  - `providerUserId` (S) — X 側の user id/handle
  - `username` (S) — 表示名/handle
  - `clientId` (S)
  - `clientSecret` (S) — 当面平文保存
  - `accessToken` (S)
  - `refreshToken` (S)
  - `tokenExpiresAt` (N)
  - `scopes` (S)
  - `authState` (S) — `authorized`|`reauth_required`|`revoked`
  - `autoPostEnabled` (BOOL)
  - `createdAt` (N), `updatedAt` (N)

  注: `appOnly` と `isDeleted` は今回不要のため削除（保存しない）。

- `x_scheduled_posts`（予約投稿）主要属性:
  - PK: `USER#${userId}` (S)
  - SK: `SCHEDULEDPOST#${scheduledPostId}` (S)
  - `scheduledPostId` (S)
  - `accountId` (S)
  - `accountName` (S)
  - `content` (S)
  - `scheduledAt` (N)
  - `postedAt` (N) — 未投稿は `0`
  - `status` (S) — `pending`|`posted`|`failed`|`cancelled`
  - `postId` (S)
  - `generateAttempts` (N), `retryCount` (N), `nextRetryAt` (N)
  - `isDeleted` (BOOL)
  - `createdAt` (N), `updatedAt` (N)
  - `pendingForAutoPostAccount` (S) = accountId（自動投稿ジョブ用索引用）

  注: `theme` と `generateByAI` は今回不要のため削除（保存しない）。

#### インデックス/検索について
- GSI (例): `GSI_PendingByAccount` (PK=`pendingForAutoPostAccount`, SK=`scheduledAt`) — 自動投稿ワーカー用。
- GSI (例): `GSI_ByAccount` (PK=`accountId`, SK=`scheduledAt`) — フロントのアカウント単位一覧用。

#### 運用ルール（既定）
- リフレッシュ失敗: 3 回失敗で `authState = 'reauth_required'` とする。
- 重複投稿抑止・再試行: Threads と同様の既存ロジックを流用する（postingLock や条件付き UpdateItem を利用）。
- prune: Threads と同一ルールを適用（既存の prune ロジックに X の予約投稿レコードを含める）。

#### Backend: CRUD API 設計（X アカウント）

API の設計方針:
- Next.js API ルートを利用（`src/pages/api/x-accounts/*`）で既存の実装スタイルに合わせる。
- 認証: 既存の `verifyUserFromRequest` を必須とし、ユーザ固有の `userId` を PK 前提で扱う。
- バリデーション: `zod` またはハンドメイドのバリデーションを用いて入力チェック。

エンドポイント一覧（概要）:

- GET `/api/x-accounts` — ユーザの全アカウント一覧取得
  - Query: none
  - Response: 200 `{ accounts: Array<{ accountId, providerUserId, username, autoPostEnabled, authState, createdAt, updatedAt }> }`

- GET `/api/x-accounts?accountId=<id>` — 単一取得（クエリ or path で実装可）
  - Response: 200 `{ account: { ...full attributes... } }` / 404

- POST `/api/x-accounts` — 新規アカウント作成（保存は clientId/clientSecret を含む）
  - Body: `{ accountId?: string, providerUserId?: string, username: string, clientId: string, clientSecret: string, autoPostEnabled?: boolean }`
  - Validation: `username` と `clientId`/`clientSecret` 必須
  - Response: 201 `{ accountId }`

- PATCH `/api/x-accounts` — 更新（例: clientId 更新、autoPostEnabled 切替、deauthorize）
  - Body: `{ accountId: string, username?: string, clientId?: string, clientSecret?: string, autoPostEnabled?: boolean, oauthAccessToken?: string }`
  - 特殊: oauthAccessToken を `''` にしてトークン削除（deauthorize）を実行可能
  - Response: 200 `{ ok: true }`

- DELETE `/api/x-accounts` — アカウント削除
  - Body: `{ accountId: string }`
  - Behavior: Threads 実装に準じて関連 ScheduledPosts の削除も実行（`deletePostsForAccount` を呼ぶ）
  - Response: 200 `{ deleted: true }`

セキュリティ・実装ノート:
- 全ての更新系は `verifyUserFromRequest` を通す。
- `clientSecret` はレスポンスで返却時はマスク（例: `*****` のサフィックス表示）する。
- DB 更新は条件付き UpdateItem を使い、存在しない場合はエラーを返す（idempotency のため）。

エラーコード例:
- 400: validation_error
- 401: unauthorized
- 404: not_found
- 500: internal_error

---

## Threads Resolver（変換API）仕様（v1）

目的

- ユーザー名（`@user` / `user` / プロフィールURL`）を受け取り、Threads の最新投稿（または指定投稿）の**数列ID（numericId）** を返す軽量単機能APIを提供する。可能であればその投稿の本文（postBody）と公開日時も返却する。

スコープ

- 入力: `username`（必須、`@`やURLを正規化して扱う）。互換性のため `code` クエリも受け付け可能。
- 出力（成功）: `numericId`（文字列）、`postCode`（短縮コード）、`postBody`（可能ならテキスト）、`publishedAt`（ISO8601）、`source`（`html`|`playwright`）
- 永続化: **行わない**（キャッシュは呼び出し側で管理）。

API 仕様

- エンドポイント: `GET /resolve?username=<name>`（Function URL または API Gateway）
- CORS: `Access-Control-Allow-Origin` を環境変数 `CORS_ORIGIN` に従う
- 成功例:

```json
{
  "username":"akipiiiiiii",
  "postCode":"DP6DgMHCE11",
  "numericId":"18297320887283438",
  "postBody":"投稿本文テキスト...",
  "publishedAt":"2025-10-17T09:03:27Z",
  "source":"html"
}
```

- エラー例（HTTP ステータスと JSON）
  - 400: invalid_request — パラメータ不足/不正
    ```json
    { "error":"invalid_request","message":"username is required" }
    ```
  - 404: not_found — ユーザー/投稿が見つからない or 非公開
    ```json
    { "error":"not_found","message":"numeric id not found" }
    ```
  - 429: rate_limited — レート/ブロック検知
    ```json
    { "error":"rate_limited","retryAfter":60 }
    ```
  - 502: upstream_error — 外部取得失敗
    ```json
    { "error":"upstream_error","message":"fetch failed: 502" }
    ```

内部設計（DB を使わない流れ）

1. 入力正規化: `@` や profile URL を受け取り正規ユーザー名にする。バリデーションで不正な文字列や長さを弾く。
2. 軽量取得: `GET https://www.threads.net/@<username>`（必要時は `https://www.threads.net/<profilePath>`）をモバイルUAで fetch。`REQUEST_TIMEOUT_MS` を超えた場合は upstream_error を返す。
3. HTML パース: ページ内の `<script type="application/json">` を列挙し JSON.parse して `post` オブジェクトを探す。抽出対象:
   - `post.code` → `postCode`
   - `post.pk`、または `post.id.split('_')[0]` → `numericId`
   - `post.text` → `postBody`（存在すれば）
   - `post.timestamp` → `publishedAt`（ある場合）
4. 成功時は構造化して返却。抽出できなければ 404。HTTP 429 や明らかなブロック文言（captcha/too many requests 等）が HTML に含まれる場合は 429 を返す。
5. フォールバック: 必要なら Playwright を使うが、Lambda 本体に組み込むとサイズとコストが増えるため**別 Lambda に分離**し、環境変数 `PLAYWRIGHT_FALLBACK=true` のときに同期呼び出し（`Invoke`）で試行することを推奨する。

エンバイロメント変数

- `CORS_ORIGIN` — CORS 許可ドメイン
- `REQUEST_TIMEOUT_MS` — fetch のタイムアウト（ms）
- `MOBILE_USER_AGENT` — 取得に使う User-Agent（任意）
- `PLAYWRIGHT_FALLBACK` — `true`/`false`
- `PLAYWRIGHT_LAMBDA_NAME` — フォールバック先 Lambda 名（フォールバックを別関数にする場合）

運用・テスト

- `parser`（HTML→numericId+postBody 抽出）はユニットテストで堅牢化する。複数の HTML サンプル（通常ページ、ログイン要求ページ、レート制限ページ、構造変化サンプル）を用意する。 
- 本 API はステートレスなので、呼び出し側（UI / 定期バッチ）が必要に応じてキャッシュやレート制御を実装する。

セキュリティ・IAM

- DDB 利用がないため Dynamo 権限は不要。Playwright を別 Lambda にする場合は `lambda:InvokeFunction` の権限が必要。

備考

- まずは HTML パーサーを作り安定化させ、実運用でパース失敗が増えたら Playwright フォールバックを追加する段階的導入を推奨する。

---

