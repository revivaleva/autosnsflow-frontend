## 機能仕様集（feature specs）

本ファイルは `pjrule` に記載されていた各機能の詳細仕様・実装注意・テスト手順を収録します。
主要項目: 投稿削除フロー、`DeletionQueue` 設計、GSI 推奨、テストフロー等。

### 投稿削除（共通方針 - deletePostsForAccount / deleteUserPosts）

- 目的
  - アカウント編集モーダル（即時削除）および定期実行（キュー処理）で同一の削除フローを実行する。

- 呼び出し先
  - `src/lib/delete-posts-for-account.ts` に共通実装を用意。`/api/accounts/{accountId}/delete-all` と Lambda のキュー処理の双方から呼ぶ。

- 入力
  - `userId` (必須)
  - `accountId` (必須)
  - `limit` (任意、既定は AppConfig `DELETION_BATCH_SIZE` または 100)

- 挙動（厳密手順）
  1. 取得: `fetchThreadsPosts({ userId, accountId, limit })` を実行して Threads 側の投稿IDリストを取得。API エラーは即時中断して例外を投げる。
  2. 削除 (API 優先): 取得した各 `postId` に対し、DB の存在有無に関わらず必ず Threads DELETE API を実行する。成功判定は既存の `src/pages/api/threads/delete-post.ts` と同一の基準を使う（404 や Facebook の `error_subcode===33` 等は「存在しない」扱いで成功とする）。
  3. DB 同期: 外部 DELETE が成功（または存在しない扱い）なら、その `postId` と `accountId` で `ScheduledPosts` を検索し、該当レコードがあれば **物理削除**（DeleteItemCommand）を行う。
  4. 完了判定: 指定件数を処理後、追加で `fetchThreadsPosts(..., limit:1)` を実行して 0 件なら `remaining=false` とし、キューがあれば削除・アカウント `status` を `active` に戻す。残件があれば `remaining=true` を返す。

- エラー・ログ方針
  - `ExecutionLogs`（`putLog`）へ永続化するのは下記のみ:
    - `fetchThreadsPosts` の致命的エラーで処理中断（`deletion_error`）
    - 外部 DELETE の致命的エラー（権限不足等）で処理中断（`deletion_error`）
    - 削除完了時の要約（`deletion_completed`）に `deletedCount` を含める
  - それ以外の詳細ログ（取得結果一覧、各 DELETE の HTTP レスポンス、マッピングサンプル等）は CloudWatch（console.info/warn/error）へ出力する。外部通知や大量ログは `ALLOW_DEBUG_EXEC_LOGS` で制御する。

- DB 操作順序の厳守
  - 必ず API → DB（Threads API を先に呼ぶ）で行うこと。DB を参照してから API を呼ぶことはしない。

- 戻り値
  - `{ deletedCount: number, remaining: boolean }`

- 実装補足
  - 物理削除ユーティリティ `src/lib/scheduled-posts-delete.ts` は物理削除指定（`physical=true`）時に失敗したら例外を throw し、呼び出し元で再試行できるようにすること。
  - `deletePostsForAccount` は即時削除（UI）とキュー削除（Lambda）両方から利用されるため冪等性に注意する。

### 裏画面（background）キュー作成ポリシー

- 裏画面実行（`mode === 'background'`）では、Threads API の取得が `0` 件でも **必ず** `DeletionQueue` にキューを作成する。目的は `ScheduledPosts` の DB 側クリーンアップを確実に行うため。
- キュー作成時の `last_processed_at`:
  - 背景キュー作成（mode==='background'）: `0` を設定
  - 即時削除に伴うキュー作成: 現在時刻を設定してワーカー側の即時再処理を回避

### ルール更新履歴（要約）

- 即時削除とキュー削除を統一（API 優先 → DB 物理削除）
- `last_processed_at` の扱いを明確化（即時=now / background=0）
- `dryrun` オプションは恒常化せずテストコードとして扱うことを推奨

### OAuth トークン方針（oauthAccessToken のみを使用）

- 方針: 今後は `oauthAccessToken` を正式トークンとし、`accessToken` は参照・フォールバックしない。
- 未設定または期限切れのトークンは自動処理（定期実行・手動バッチ含む）から除外し、アカウント状態を `reauth_required` に設定して UI 上で再認証を促す。

### アカウント編集モーダルの認証状態表示と解除機能

- 目的
  - アカウント編集モーダル（`SNSAccountModal`）内で、認可URLのコピーボタン横に簡潔な認証状態表示（ラベル）を置き、ユーザーがトークンの有無を一目で把握できるようにする。また、認証済であればワンクリックで認証解除（DB上のトークン削除）できるUIを提供する。

- 表示要件
  - 認証済み: `oauthAccessToken` または従来の `accessToken` の存在をもって「認証済み」と表示（緑のバッジ）。
  - 未認証: トークンが存在しない場合は「未認証」をグレーで表示。
  - モーダル表示時には可能な限り最新のDB状態を反映する。最短実装はモーダルに渡された `account` オブジェクト上のフィールドから判定する方法、推奨はモーダル表示時に `/api/threads-accounts?accountId=...` 等で最新値をフェッチして反映する。

- 解除（Deauthorize）ボタン挙動
  - 解除は確認ダイアログを表示したうえで実行する（同期的な confirm で可）。
  - クライアント側は `PATCH /api/threads-accounts` を呼び、ペイロードに `accountId` と `oauthAccessToken: ''` を含めることで DB 上のトークンを空にする。API 側は受けて UpdateItemCommand でフィールドを上書きできること。
  - 成功時のクライアント側処理:
    - UI 上のトークン関連 state (`accessToken`, `clientSecretMasked` 等) をクリアして「未認証」表示に切替える。
    - `reloadAccounts()` を呼んで一覧を更新する（必要に応じてモーダルを閉じる）。
    - ユーザー向けに成功メッセージ（alert など）を表示する。
  - 失敗時の処理:
    - エラーメッセージを alert 表示し、UI state は変更しない。

- セキュリティ・監査
  - トークン削除リクエストは認証済みユーザーであることを前提とし、サーバー側で `verifyUserFromRequest` を通すこと。
  - 監査のため、サーバー側でトークン削除操作（deauthorize）を ExecutionLogs に `action: 'deauthorize', initiatedBy: <userId>, accountId: <id>` として保存することを推奨。

- テスト
  - 単体テスト: モーダルの認証ラベルが `account` オブジェクトの `oauthAccessToken` 存在に応じて正しくレンダリングされること。
  - e2e/インテグレーション: 実際に PATCH を行って DB 上のトークンが消えることを確認し、UI が更新されることを検証する。スタブ/モックが利用可能な環境であれば PATCH の応答をモックして UI の分岐を確認する。


### トークン自動更新（auto-refresh）設計（概要）

- 目的: トークンの有効期限が近い場合に自動で更新（長期化）し、手動での再認証負荷を軽減する。
- 実装案（高レベル）:
  1. ThreadsAccounts に `oauthAccessToken`, `oauthAccessTokenExpiresAt`（Epoch 秒）を保持する。
  2. 定期ワーカー（例: `token-refresh` ジョブ）を導入し、`oauthAccessTokenExpiresAt - now <= REFRESH_THRESHOLD_SEC` のアカウントを検出して更新を試みる。
  3. 更新フロー: OAuth の long-lived 交換エンドポイント（`/access_token?grant_type=th_exchange_token` 等）を呼び、成功したら新しい `oauthAccessToken` と `expiresAt` を保存する。失敗（権限不足・拒否など）の場合は `status = 'reauth_required'` を設定し、ExecutionLogs に `oauth_refresh_failed` を記録する。
  4. セキュリティ: client_secret は Secrets Manager を用い、ログ出力ではトークン本体を決して出力しない（長さやマスクのみ可）。

- 運用パラメータ（環境変数）:
  - `TOKEN_REFRESH_THRESHOLD_SEC`（デフォルト: 60 * 60 * 24 = 1日）
  - `TOKEN_REFRESH_BATCH_SIZE`（1回あたりの更新対象件数）

- フォールバック: 自動更新に失敗した場合でも自動で `accessToken` を利用する等のフォールバックは行わない。再認証はユーザー操作で行う。

### アカウントステータスと UI 表示

- `ThreadsAccounts.status` に新しい値 `reauth_required` を追加。UI はこのステータスを検出して、アカウント一覧の状態欄に「要再認証」バッジと再認証ボタンを表示すること。
- ステータス変更はバッチ処理中に発生する可能性があるため、UI 側はリアルタイム更新を考慮する（ポーリングまたは WebSocket）。


---

### X（旧Twitter）統合仕様（追加）

- API ベース: `https://api.x.com/2`
- 認可方式: OAuth2.0（Authorization Code + PKCE）
- Token 取得: `POST https://api.x.com/2/oauth2/token`
- スコープ (初期): `tweet.write tweet.read users.read offline.access media.write`
- コールバック: `https://threadsbooster.jp/api/auth/x/callback`

方針メモ:
- Threads と同様の認証フロー（state + PKCE, リフレッシュ処理）を再利用する。
- clientSecret 等は当面 DB テーブルに平文で保存（Threads と同様）。将来的に Secrets Manager へ移行推奨。

重要（clientId/clientSecret とトークン取得の方針）:
- **必須方針**: X の `clientId` / `clientSecret` 系は **一切の環境変数フォールバックを行わない**。必ず対象のアカウントレコード（`x_accounts` テーブル内の該当 `ACCOUNT#<accountId>`）から読み出すこと。複数アカウント運用を前提に、ソースコードの可読性と運用の一貫性を保つためです。
- 実装要件:
  - 認可開始（`/api/x/authorize`）およびコールバック（`/api/x/callback`）は、該当アカウントの `clientId` / `clientSecret` を **DB から取得**することを前提に実装する。
  - DB に対象の `clientId` または `clientSecret` が存在しない場合は、処理は **即時エラー終了** とし、明確なエラーメッセージ（例: `client_id or client_secret not configured`）を返すこと。環境変数や AppConfig に値があっても X 用のクライアント情報のフォールバックには使わない。
- トークン取得/投稿時のトークン非存在時挙動:
  - 投稿処理（`/api/x/tweet` や定期ジョブ）は、対象アカウントから `oauthAccessToken`（または `accessToken` のフォールバックは不可とする）を取得できない場合、即時エラー（403 または 4xx）で終了してよい。
  - システムログ及び ExecutionLogs に該当の `accountId` とエラー詳細を記録すること（トークン自体や client_secret の値はログに出力しない）。


#### DynamoDB スキーマ案（要点・簡潔）

- テーブル名（環境変数で指定）
  - `TBL_X_ACCOUNTS`（例: `XAccounts`）
  - `TBL_X_SCHEDULED`（例: `XScheduledPosts`）

- `x_accounts`（ユーザごとの X アカウント）主要属性:
  - PK: `USER#${userId}` (S)
  - SK: `ACCOUNT#${accountId}` (S)
  - `accountId` (S)
  - `providerUserId` (S) — X 側の user id/handle
  - `username` (S) — 表示名/handle
  - `clientId` (S)
  - `clientSecret` (S) — 当面平文保存
  - `accessToken` (S)
  - `refreshToken` (S)
  - `tokenExpiresAt` (N)
  - `scopes` (S)
  - `authState` (S) — `authorized`|`reauth_required`|`revoked`
  - `autoPostEnabled` (BOOL)
  - `createdAt` (N), `updatedAt` (N)

  注: `appOnly` と `isDeleted` は今回不要のため削除（保存しない）。

- `x_scheduled_posts`（予約投稿）主要属性:
  - PK: `USER#${userId}` (S)
  - SK: `SCHEDULEDPOST#${scheduledPostId}` (S)
  - `scheduledPostId` (S)
  - `accountId` (S)
  - `accountName` (S)
  - `content` (S)
  - `scheduledAt` (N)
  - `postedAt` (N) — 未投稿は `0`
  - `status` (S) — `pending`|`posted`|`failed`|`cancelled`
  - `postId` (S)
  - `generateAttempts` (N), `retryCount` (N), `nextRetryAt` (N)
  - `isDeleted` (BOOL)
  - `createdAt` (N), `updatedAt` (N)
  - `pendingForAutoPostAccount` (S) = accountId（自動投稿ジョブ用索引用）

  注: `theme` と `generateByAI` は今回不要のため削除（保存しない）。

#### インデックス/検索について
- GSI (例): `GSI_PendingByAccount` (PK=`pendingForAutoPostAccount`, SK=`scheduledAt`) — 自動投稿ワーカー用。
- GSI (例): `GSI_ByAccount` (PK=`accountId`, SK=`scheduledAt`) — フロントのアカウント単位一覧用。
- GSI (推奨): `GSI_ByAccountDate` (PK=`accountId`, SK=`scheduledDateYmd`) — 当日分限定で高速に候補を取得するためのインデックス。  
  - 使い方: 自動投稿ジョブではまず `scheduledDateYmd`（JSTの日付文字列: `YYYYMMDD`）で当日分のみを Query し、戻り値から `scheduledAt <= now` の候補を選択することで前日の予約をそもそも取得しないようにできます。  
  - 注意: 新規に作成する予約では必ず `scheduledDateYmd` を保存すること（既存アイテムのバックフィルは行わない運用とする）。

#### 運用ルール（既定）
- リフレッシュ失敗: 3 回失敗で `authState = 'reauth_required'` とする。
- 重複投稿抑止・再試行: Threads と同様の既存ロジックを流用する（postingLock や条件付き UpdateItem を利用）。
- prune: Threads と同一ルールを適用（既存の prune ロジックに X の予約投稿レコードを含める）。

#### Backend: CRUD API 設計（X アカウント）

API の設計方針:
- Next.js API ルートを利用（`src/pages/api/x-accounts/*`）で既存の実装スタイルに合わせる。
- 認証: 既存の `verifyUserFromRequest` を必須とし、ユーザ固有の `userId` を PK 前提で扱う。
- バリデーション: `zod` またはハンドメイドのバリデーションを用いて入力チェック。

エンドポイント一覧（概要）:

- GET `/api/x-accounts` — ユーザの全アカウント一覧取得
  - Query: none
  - Response: 200 `{ accounts: Array<{ accountId, providerUserId, username, autoPostEnabled, authState, createdAt, updatedAt }> }`

- GET `/api/x-accounts?accountId=<id>` — 単一取得（クエリ or path で実装可）
  - Response: 200 `{ account: { ...full attributes... } }` / 404

- POST `/api/x-accounts` — 新規アカウント作成（保存は clientId/clientSecret を含む）
  - Body: `{ accountId?: string, providerUserId?: string, username: string, clientId: string, clientSecret: string, autoPostEnabled?: boolean }`
  - Validation: `username` と `clientId`/`clientSecret` 必須
  - Response: 201 `{ accountId }`

- PATCH `/api/x-accounts` — 更新（例: clientId 更新、autoPostEnabled 切替、deauthorize）
  - Body: `{ accountId: string, username?: string, clientId?: string, clientSecret?: string, autoPostEnabled?: boolean, oauthAccessToken?: string }`
  - 特殊: oauthAccessToken を `''` にしてトークン削除（deauthorize）を実行可能
  - Response: 200 `{ ok: true }`

- DELETE `/api/x-accounts` — アカウント削除
  - Body: `{ accountId: string }`
  - Behavior: Threads 実装に準じて関連 ScheduledPosts の削除も実行（`deletePostsForAccount` を呼ぶ）
  - Response: 200 `{ deleted: true }`

セキュリティ・実装ノート:
- 全ての更新系は `verifyUserFromRequest` を通す。
- `clientSecret` はレスポンスで返却時はマスク（例: `*****` のサフィックス表示）する。
- DB 更新は条件付き UpdateItem を使い、存在しない場合はエラーを返す（idempotency のため）。

エラーコード例:
- 400: validation_error
- 401: unauthorized
- 404: not_found
- 500: internal_error

---

## Threads Resolver（変換API）仕様（v1）

目的

- ユーザー名（`@user` / `user` / プロフィールURL`）を受け取り、Threads の最新投稿（または指定投稿）の**数列ID（numericId）** を返す軽量単機能APIを提供する。可能であればその投稿の本文（postBody）と公開日時も返却する。

スコープ

- 入力: `username`（必須、`@`やURLを正規化して扱う）。互換性のため `code` クエリも受け付け可能。
- 出力（成功）: `numericId`（文字列）、`postCode`（短縮コード）、`postBody`（可能ならテキスト）、`publishedAt`（ISO8601）、`source`（`html`|`playwright`）
- 永続化: **行わない**（キャッシュは呼び出し側で管理）。

API 仕様

- エンドポイント: `GET /resolve?username=<name>`（Function URL または API Gateway）
- CORS: `Access-Control-Allow-Origin` を環境変数 `CORS_ORIGIN` に従う
- 成功例:

```json
{
  "username":"akipiiiiiii",
  "postCode":"DP6DgMHCE11",
  "numericId":"18297320887283438",
  "postBody":"投稿本文テキスト...",
  "publishedAt":"2025-10-17T09:03:27Z",
  "source":"html"
}
```

- エラー例（HTTP ステータスと JSON）
  - 400: invalid_request — パラメータ不足/不正
    ```json
    { "error":"invalid_request","message":"username is required" }
    ```
  - 404: not_found — ユーザー/投稿が見つからない or 非公開
    ```json
    { "error":"not_found","message":"numeric id not found" }
    ```
  - 429: rate_limited — レート/ブロック検知
    ```json
    { "error":"rate_limited","retryAfter":60 }
    ```
  - 502: upstream_error — 外部取得失敗
    ```json
    { "error":"upstream_error","message":"fetch failed: 502" }
    ```

内部設計（DB を使わない流れ）

1. 入力正規化: `@` や profile URL を受け取り正規ユーザー名にする。バリデーションで不正な文字列や長さを弾く。
2. 軽量取得: `GET https://www.threads.net/@<username>`（必要時は `https://www.threads.net/<profilePath>`）をモバイルUAで fetch。`REQUEST_TIMEOUT_MS` を超えた場合は upstream_error を返す。
3. HTML パース: ページ内の `<script type="application/json">` を列挙し JSON.parse して `post` オブジェクトを探す。抽出対象:
   - `post.code` → `postCode`
   - `post.pk`、または `post.id.split('_')[0]` → `numericId`
   - `post.text` → `postBody`（存在すれば）
   - `post.timestamp` → `publishedAt`（ある場合）
4. 成功時は構造化して返却。抽出できなければ 404。HTTP 429 や明らかなブロック文言（captcha/too many requests 等）が HTML に含まれる場合は 429 を返す。
5. フォールバック: 必要なら Playwright を使うが、Lambda 本体に組み込むとサイズとコストが増えるため**別 Lambda に分離**し、環境変数 `PLAYWRIGHT_FALLBACK=true` のときに同期呼び出し（`Invoke`）で試行することを推奨する。

エンバイロメント変数

- `CORS_ORIGIN` — CORS 許可ドメイン
- `REQUEST_TIMEOUT_MS` — fetch のタイムアウト（ms）
- `MOBILE_USER_AGENT` — 取得に使う User-Agent（任意）
- `PLAYWRIGHT_FALLBACK` — `true`/`false`
- `PLAYWRIGHT_LAMBDA_NAME` — フォールバック先 Lambda 名（フォールバックを別関数にする場合）

運用・テスト

- `parser`（HTML→numericId+postBody 抽出）はユニットテストで堅牢化する。複数の HTML サンプル（通常ページ、ログイン要求ページ、レート制限ページ、構造変化サンプル）を用意する。 
- 本 API はステートレスなので、呼び出し側（UI / 定期バッチ）が必要に応じてキャッシュやレート制御を実装する。

セキュリティ・IAM

- DDB 利用がないため Dynamo 権限は不要。Playwright を別 Lambda にする場合は `lambda:InvokeFunction` の権限が必要。

備考

- まずは HTML パーサーを作り安定化させ、実運用でパース失敗が増えたら Playwright フォールバックを追加する段階的導入を推奨する。

---

