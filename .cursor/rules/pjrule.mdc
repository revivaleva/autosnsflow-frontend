---
description:
プロジェクト共通の運用ルール、ブランチ運用、コマンド実行ポリシー、デバッグ出力方針などをここに記載します。

（既に存在していた詳細な機能仕様は `.cursor/rules/pjspec.mdc` に移動済み）

## ブランチ運用（必読）

- **main**：本番。ここへは「明示指示があった時のみ」マージ。直接 push 禁止。
- **staging**：通常の開発・修正・デバッグはここへ。特段の指示が無い場合は staging。
- **lambda**：定期実行関連は必ずここへ push。共通部分は staging 経由で反映。

## コマンド実行ポリシー

- 原則：1 ステップ = 1 コマンド。ワンライナー連結（`&&`）禁止。
- 実行方法、守護ランナー、ログ保存等の運用手順をここに記載する。

### WSL 経由での Git 操作（重要）

- 方針: リポジトリが WSL 環境（Ubuntu 等）にある場合、Git 操作は **必ず WSL 側のシェルで1コマンドずつ** 実行してください。Windows 側の PowerShell / CMD で WSL パスを直接扱ったり、長いワンライナーを投げることは禁止します。
- 理由: PowerShell と WSL ではパス解釈・メタデータ・改行扱いが異なるため、誤動作や意図しないファイル追加（例: Zone.Identifier のような ADS）が発生しやすくなります。
- 実行ルール（厳守）:
  1. 1回の呼び出しで 1 つの Git 操作のみ行う（例: `git status`、`git add <file>`、`git commit -m "..."`、`git push` をそれぞれ別コマンドで実行）。
  2. WSL 経由で実行する場合の推奨コマンド例（1行で WSL を呼ぶが、実際に行う操作は単一の git サブコマンドに限定）:
     - cd して状態確認:
       ```bash
       wsl -d Ubuntu -u revival bash -lc 'cd /home/revival/projects/AutoSNSFlow/frontend; git status --porcelain=2 --branch'
       ```
     - ファイルをステージ:
       ```bash
       wsl -d Ubuntu -u revival bash -lc 'cd /home/revival/projects/AutoSNSFlow/frontend; git add path/to/file'
       ```
     - コミット:
       ```bash
       wsl -d Ubuntu -u revival bash -lc 'cd /home/revival/projects/AutoSNSFlow/frontend; git commit -m "message"'
       ```
     - push:
       ```bash
       wsl -d Ubuntu -u revival bash -lc 'cd /home/revival/projects/AutoSNSFlow/frontend; git push origin staging'
       ```
  3. 1 つの `bash -lc` 内で複数の Git サブコマンドを `;` で連結して実行することは避けてください。`bash -lc` はあくまで単一操作を WSL 上で呼び出すためのラッパーと考えてください。
  4. 長いファイル名/パスの問題が発生した場合は `git config --system core.longpaths true` を Windows 側で設定するか、該当ファイルを `.gitignore` に追加して index から外してください。

これらのルールを守ることで、PowerShell と WSL 間の差異による失敗を防ぎ、pjrule の「1 ステップ = 1 コマンド」方針と整合します。

## デバッグ出力ポリシー

- 本番での恒常的な外部Webhook直打ちや大量のconsole出力は禁止。調査時は `ALLOW_DEBUG_EXEC_LOGS` で制御する。

---

（詳細は `.cursor/rules/pjspec.mdc` を参照）

---
description:
あなたは高度な問題解決能力を持つAIアシスタントです。以下の指示に従って、効率的かつ正確にタスクを遂行してください。

まず、ユーザーから受け取った指示を確認します：

<指示>
{{instructions}}
</指示>

この指示を元に、以下のプロセスに従って作業を進めてください。なお、すべての提案と実装は、記載された技術スタックの制約内で行ってください：

1. 指示の分析と計画
<タスク分析>
- 主要なタスクを簡潔に要約してください。
- 記載された技術スタックを確認し、その制約内での実装方法を検討してください。
- 重要な要件と制約を特定してください。
- 潜在的な課題をリストアップしてください。
- タスク実行のための具体的なステップを詳細に列挙してください。
- それらのステップの最適な実行順序を決定してください。
- 必要となる可能性のあるツールやリソースを考慮してください。

このセクションは、後続のプロセス全体を導くものなので、時間をかけてでも、十分に詳細かつ包括的な分析を行ってください。
この指示を確認した場合、「作業を行う前にruleを確認しました」と出力してから作業を開始してください。
</タスク分析>

2. タスクの実行
- 特定したステップを一つずつ実行してください。
- 各ステップの完了後、簡潔に進捗を報告してください。
- 実行中に問題や疑問が生じた場合は、即座に報告し、対応策を提案してください。

3. 品質管理
- 各タスクの実行結果を迅速に検証してください。
- エラーや不整合を発見した場合は、直ちに修正アクションを実施してください。
- コマンドを実行する場合は、必ず標準出力を確認し、結果を報告してください。

4. 最終確認
- すべてのタスクが完了したら、成果物全体を評価してください。
- 当初の指示内容との整合性を確認し、必要に応じて調整を行ってください。

重要な注意事項：
- 不明点がある場合は、作業開始前に必ず確認を取ってください。
- 重要な判断が必要な場合は、その都度報告し、承認を得てください。
- 予期せぬ問題が発生した場合は、即座に報告し、対応策を提案してください。

---

## ブランチ運用（必読）

- **main**：本番。ここへは「明示指示があった時のみ」マージ。直接 push 禁止。  
- **staging**：通常の開発・修正・デバッグはここへ。特段の指示が無い場合は staging。  
- **lambda**：定期実行（`scheduled` / `auto-post` / `lambda/scheduled-autosnsflow`）関連は必ずここへ push。push で自動ビルド/デプロイが走る。  

共通部分（`src/lib/` 配下）は **staging → main → lambda の順に反映**。  
定期実行専用処理（`lambda/` 配下）は **lambda ブランチ直 push も可**。ただし共通部分を修正する場合は必ず staging を経由する。  

---

## 引用投稿（Quote-Posts）仕様

- 目的: 監視対象アカウントの最新投稿を定期的に取得し、AIで引用文を生成してThreadsの引用投稿APIを用いて投稿する自動化フローを追加する。  

- 主な構成要素:  
  - 監視設定: `SNSAccountModal` に `monitoredAccountId` を追加し、1アカウントにつき1つの監視対象IDを登録できること。  
  - アカウントフラグ: `SNSAccountsTable` に `autoQuote` を追加。`autoQuote` が true のアカウントのみ引用予約を作る。  
  - Hourly ワーカー: 1時間毎に `monitoredAccountId` を持ち `autoQuote=true` のアカウントを走査し、対象ユーザーの最新投稿を1件取得。未引用であれば予約投稿（`type: "quote"`, `quoteText: null`, `status: "pending_quote"`, `targetPostId` を metadata に保存）を作成する（実際の投稿はしない）。  
  - 5分ワーカー: 5分毎に `status: "pending_quote"` の予約投稿を取得し、以下の順で処理する：  
    1. `autoGenerate` が true の場合のみAIで本文を生成（既存の投稿生成と同じAIプロバイダ／モデル／プロンプト参照ルールを利用）。  
    2. 生成済みの本文を `autoPost` が true の場合に限りThreadsの引用投稿APIで投稿する。  
    3. 投稿成功時は予約を `posted` に更新し、既存の予約投稿の後処理（リプ返信フロー等）を適用する。  

- フラグの優先順位（ワーカー実行時の判定）:  
  - まず `autoQuote` が true でなければ Hourly による予約作成対象外。  
  - 5分ワーカーでの本文生成は `autoGenerate` フラグに従う（false の場合は quoteText を空のままにするか、生成をスキップして投稿を行わない）。  
  - 実際の投稿実行は `autoPost` フラグに従う（false の場合は投稿せず予約を保持またはキャンセル）。  

- 重複防止: 同一 `targetPostId` を重複して引用しない。DBに保存された `targetPostId` をチェックし、既存の予約／投稿がある場合はスキップする。  

- プロンプト管理: 引用文生成用プロンプトは設定画面で登録可能。未登録時は `AppConfig` の既定値を使用する。既存のAI生成設定を流用し、プロバイダやモデルの重複登録を避ける。  

- UI 仕様:  
  - `SNSAccountsTable` に `引用投稿` 列を新設し、`リプ返信` 列の右側に表示する。トグルは専用の列で表示し、行幅や整列が崩れないよう調整する。  
  - 予約投稿一覧には `引用元投稿ID` 列を追加し、投稿IDをクリックすると該当投稿を開けるようにする。  
  - 予約投稿のフィルターに「引用投稿 / 通常投稿」の切替を追加する。  

- エラー処理と運用:  
  - API呼び出しの失敗やレート制限はExecutionLogsへ記録し、指数バックオフ等のリトライ戦略を使う。  
  - 必要に応じて引用予約作成の監査ログを残し、運用者が容易に調査できるようにする。  

- 実装分割ルール:  
  - Hourly ワーカーは予約作成までを担当。  
  - 5分ワーカーは本文生成と実投稿を担当する（役割を分離してテストを容易にする）。  


## デザイン指針

- Tailwind CSS のみで構成。ライト/ダーク両対応、将来のモバイル（レスポンシブ）前提。  
- ローダー/モーダル等の共通部品を統一し、画面間の一貫性を確保。  

## ローディング表示の共通化ルール

- 目的: ユーザー体験の一貫性確保と実装重複の防止のため、全てのグローバル/ブロッキングなローディング表示は共通コンポーネント `LoadingOverlay` を使用すること。
- 適用範囲: ポップアップ（モーダル）内での非同期処理、ページ全体のブロッキング処理、バッチ実行（当日自動作成／投稿全削除等）のローディング表示。
- 実装ルール:
  - `LoadingOverlay` を import して `open` / `message` プロパティで制御すること。直接 DOM に DOM 要素を挿入する独自ローディングを作らないこと。
  - 例外的に特殊なアニメーション等が必要な場合はデザイナーと合意のうえ共通コンポーネントを拡張し、その拡張を全体に展開すること。
  - デバッグ用の一時的な console.log や個別のスピナーは `ALLOW_DEBUG_EXEC_LOGS` のフラグにより制御すること。

これにより、今後のローディングUIは `LoadingOverlay` を共通で利用してください。

---

## 変更時の原則

- どのブランチに上げるかを必ず明示。不明点は修正せず確認。  
- 既存ロジックを大きく変える提案は一度確認（互換影響の洗い出しを含む）。  
 - 外部APIや重要な取得処理の失敗時に**安易なフォールバックを追加して問題を隠蔽しないこと**。
   フォールバックを実装する場合は、事前に影響範囲と根本原因の確認を行い、設計書・PR に理由と代替案を明示してレビュワーの承認を得ること。
   重要な設定（例: AppConfig の読み込み等）は fail-fast を採用し、起動時・処理開始時に読み込めない場合は明確にエラーを返して停止する運用を優先する。
- 共通部品の変更は呼び出し元全体の動作確認をセット。  

---

## 定期実行（Lambda）ポリシー

- 対象語：`定期実行` / `自動投稿` / `scheduled` / `auto-post` / `lambda/scheduled-autosnsflow` を含む変更は Lambda 関連とみなす。  
- lambda ブランチにコミット/PR。コミットメッセージ・PR タイトルに `lambda:` を付与。  
- デプロイ前にローカル or ステージングで確認。main 反映は事前了承があるときのみ。  

---

## シークレット取り扱い

- APIキー/トークン/個人情報のコミット禁止。`.env.*` は `.gitignore`。  
- デプロイ時は GitHub Secrets / AWS Secrets Manager を使用。  
- CI に `git-secrets` / `truffleHog` を導入し、検出時はブロック。  
- 漏洩時は即ローテート＋履歴除去（`git filter-repo` 等）＋報告。  

---

## コマンド実行ポリシー

必須環境：**Windows PowerShell** を基本とする。  
原則：1 ステップ = 1 コマンド。ワンライナー連結（`&&`）禁止。  

### 1) 守護ランナーの使用
- `cx_run <job> <timeoutSec> "<cmd>"` で実行し、タイムアウト・ログ保存・未尾200行のみ表示を徹底。  
- 止まった時は `cx_stop <job>` を提示して強制停止できる形にする。  
- ログは `/tmp/cursor_guard/<job>_YYYYMMDD_HHMMSS.log`。  

### 2) Git 操作は非対話＋タイムアウト
- UNC パスを用い、必ず `-C` でリポジトリパスを明示する。  
- 例:  
  ```powershell
  git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" status
commit は必ず -m 指定。必要時のみ --no-verify。

操作前後で git status --porcelain を実行して確認。

認証は SSH 鍵前提。プロンプト待ち禁止。

3) 出力・ログの扱い
長い出力は必ずファイルへ（> /tmp/*.json / /tmp/*.log）。

JSON 確認は jq。画面は要点のみ表示。

4) 長い/複雑な処理
長文コマンドや here-doc は /tmp/*.sh に保存して実行。

各ステップで結果を確認してから次へ進む。

5) 例（ワンライナー禁止 → 分割推奨）
NG:

sh
コードをコピーする
git rm -r --cached A B && git commit -m "chore" && git push origin lambda
OK:

powershell
コードをコピーする
git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" rm -r --cached A B
git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" status --porcelain
git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" commit -m "chore: remove test artifacts" --no-verify
git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" push --porcelain --no-verify origin lambda
ビルド
powershell
コードをコピーする
cx_run build 1800 "npm ci"
cx_run build 1800 "npm run build"
cx_run lsout 30  "ls -lh .next | tail -n 50"
事故復旧
実行が進まない場合
cx_stop <job>

powershell
コードをコピーする
Get-ChildItem -Recurse .git\*.lock | Remove-Item -Force
git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" status --porcelain
端末不調時
Clear-Host でターミナルリセット

必要に応じて PowerShell 再起動

ビルド/マージ注意（CI 向け短縮版）
マージ競合マーカー（<<<<<<< / ======= / >>>>>>>）を残したまま push すると CI が失敗。必ず解消して確認。

解消後は明示的に git add → commit する（自動 commit 禁止）。

ローカルで npm run build または tsc を実行し構文・型チェックを通す。

push は原則 --force 禁止。必要なら --force-with-lease を使用。

DynamoDB の AttributeValue を直接返さない。必ず正規化。

---

ワークツリー全体をステージする操作 (git add -A) の注意
git add -A は未追跡ファイルも含めるため、個人環境ファイルや長いファイル名の混入リスクがある。

安全な手順:

git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" status --porcelain

不要ファイルは .gitignore へ追加

必要ファイルのみ git add <path> または git add -p

Windows 側で長いパスエラーが出る場合は .gitignore に追加するか、core.longpaths を有効化

powershell
コードをコピーする
git config --system core.longpaths true
追記: PowerShell 環境での Git 操作について
本プロジェクトは Windows + WSL の併用環境。PowerShell 側から UNC パスで WSL 内を指定する。

例:

powershell
コードをコピーする
git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" <command>
ステップ実行を徹底。&& 禁止。長い出力はログへ保存して確認。

推奨ワークフロー（commit → staging push）
git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" add <files...>

git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" commit -m "<msg>"

git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" checkout staging（なければ checkout -b staging）

git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" merge --no-edit main

git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" push origin staging

---

## テスト方針（実データによる手動検証）

- 方針: モックは使わず、実運用データを用いて手動で検証を行います。まずは削除処理（即時/キュー/キューからの定期実行）を小さいバッチで確認し、その後本番想定のケースで最終チェックを行います。

- 対象ケース:
  - アカウントA: 投稿合計が 100 件以下のアカウント（全件一括削除が完了することを確認）
  - アカウントB: 投稿合計が 100 件を超えるアカウント（複数バッチに分割されることを確認）

- 検証手順（段階的）:
  1. バッチサイズをテスト用に小さく設定（例: 10 件）する。
  2. UI の「即時削除(バッチ)」で 10 件削除を実行し、API の応答と UI の反映（削除件数・残件表示・ExecutionLogs）を確認する。
  3. UI の「裏画面実行(キュー化)」でキューを作成し、`DeletionQueue` テーブルにエントリが作成されることを確認する。
  4. 定期ワーカー（または手動でワーカー処理をトリガー）を実行して、キューから削除処理が実行されることを確認する（各バッチで 10 件ずつ削除されることを期待）。
  5. すべて削除されたら、`DeletionQueue` の該当エントリが削除され、アカウントの `status` が `active` に戻ることを確認する。

- 本番想定の最終チェック:
  - 上記の基本検証が通ったら、バッチサイズを 100 に戻し、
    - アカウントA(<=100) で全削除が一回で完了すること、
    - アカウントB(>100) で複数バッチに分かれて最終的に全削除されることを確認する。

- 注意事項:
  - 実データを用いるため、事前にバックアップや復旧手順を必ず確認してください。
  - テスト中は自動投稿を抑止（アカウントの `status = 'deleting'`）しておくこと。
  - バッチサイズを小さくすると削除に時間がかかるため、実施時間を運用チームと調整してください。

- 優先度: 高（まずは定期実行ワーカーの見直しを優先し、その後上記の手順で検証を実行）

---

## デバッグ出力ポリシー

- 目的: 本番環境へ無秩序なデバッグ出力や外部通知を残さず、調査時のみ安全に出力を許可するためのガイドライン。

- 基本原則:
  - 本番での恒常的な外部Webhook直打ちや大量のconsole出力を禁止する。
  - 調査目的で一時的に外部通知を行う場合は、必ず `ALLOW_DEBUG_EXEC_LOGS`（値 `'true'` または `'1'`）で有効化すること。
  - シークレット（accessToken, clientSecret 等）は決して出力してはならない。出力が必要な場合はマスクして記録する。

- 実装ルール:
  1. 外部通知（Discord/Slack等）や詳細な診断は `if (process.env.ALLOW_DEBUG_EXEC_LOGS === 'true' || process.env.ALLOW_DEBUG_EXEC_LOGS === '1')` でガードすること。
  2. 永続的な調査記録は `ExecutionLogs`（`putLog`）へ構造化して保存し、外部通知は運用アラート経路で別途送信すること。
  3. デバッグコードを追加する際は PR に明記し、レビューで必ず削除またはフラグ制御されていることを確認すること。
  4. デバッグ有効化は運用者のみが切り替えられるよう権限を制限すること（IAM ポリシーで制御）。

- 運用注意:
  - デバッグを有効にしたまま本番で長期間放置しない。必ず作業後に `ALLOW_DEBUG_EXEC_LOGS` を無効化する。
  - 外部通知はレート制御やサンプリングを行い、運用サービスへの負荷・スパムを防ぐこと。

## ローカルでのビルド検証（推奨コマンド）

- WSL 上でビルドと型チェックを実行する際は、必ずプロジェクトの frontend ディレクトリで次のコマンドを実行してください:

  ```powershell
  wsl -d Ubuntu -u revival bash -lc "cd /home/revival/projects/AutoSNSFlow/frontend && npm run build"
  ```

  - 実行前に `npm ci` を行い、`.env.local` 等の環境変数を準備してください。
  - ビルド失敗時は出力ログを保存して原因を特定し、修正後に再実行してください。

