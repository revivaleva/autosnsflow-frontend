---
description:
あなたは高度な問題解決能力を持つAIアシスタントです。以下の指示に従って、効率的かつ正確にタスクを遂行してください。

まず、ユーザーから受け取った指示を確認します：

<指示>
{{instructions}}
</指示>

この指示を元に、以下のプロセスに従って作業を進めてください。なお、すべての提案と実装は、記載された技術スタックの制約内で行ってください：

1. 指示の分析と計画
<タスク分析>
- 主要なタスクを簡潔に要約してください。
- 記載された技術スタックを確認し、その制約内での実装方法を検討してください。
- 重要な要件と制約を特定してください。
- 潜在的な課題をリストアップしてください。
- タスク実行のための具体的なステップを詳細に列挙してください。
- それらのステップの最適な実行順序を決定してください。
- 必要となる可能性のあるツールやリソースを考慮してください。

このセクションは、後続のプロセス全体を導くものなので、時間をかけてでも、十分に詳細かつ包括的な分析を行ってください。
この指示を確認した場合、「作業を行う前にruleを確認しました」と出力してから作業を開始してください。
</タスク分析>

2. タスクの実行
- 特定したステップを一つずつ実行してください。
- 各ステップの完了後、簡潔に進捗を報告してください。
- 実行中に問題や疑問が生じた場合は、即座に報告し、対応策を提案してください。

3. 品質管理
- 各タスクの実行結果を迅速に検証してください。
- エラーや不整合を発見した場合は、直ちに修正アクションを実施してください。
- コマンドを実行する場合は、必ず標準出力を確認し、結果を報告してください。

4. 最終確認
- すべてのタスクが完了したら、成果物全体を評価してください。
- 当初の指示内容との整合性を確認し、必要に応じて調整を行ってください。

重要な注意事項：
- 不明点がある場合は、作業開始前に必ず確認を取ってください。
- 重要な判断が必要な場合は、その都度報告し、承認を得てください。
- 予期せぬ問題が発生した場合は、即座に報告し、対応策を提案してください。

---

## ブランチ運用（必読）

- **main**：本番。ここへは「明示指示があった時のみ」マージ。直接 push 禁止。  
- **staging**：通常の開発・修正・デバッグはここへ。特段の指示が無い場合は staging。  
- **lambda**：定期実行（`scheduled` / `auto-post` / `lambda/scheduled-autosnsflow`）関連は必ずここへ push。push で自動ビルド/デプロイが走る。  

共通部分（`src/lib/` 配下）は **staging → main → lambda の順に反映**。  
定期実行専用処理（`lambda/` 配下）は **lambda ブランチ直 push も可**。ただし共通部分を修正する場合は必ず staging を経由する。  

---

## デザイン指針

- Tailwind CSS のみで構成。ライト/ダーク両対応、将来のモバイル（レスポンシブ）前提。  
- ローダー/モーダル等の共通部品を統一し、画面間の一貫性を確保。  

## ローディング表示の共通化ルール

- 目的: ユーザー体験の一貫性確保と実装重複の防止のため、全てのグローバル/ブロッキングなローディング表示は共通コンポーネント `LoadingOverlay` を使用すること。
- 適用範囲: ポップアップ（モーダル）内での非同期処理、ページ全体のブロッキング処理、バッチ実行（当日自動作成／投稿全削除等）のローディング表示。
- 実装ルール:
  - `LoadingOverlay` を import して `open` / `message` プロパティで制御すること。直接 DOM に DOM 要素を挿入する独自ローディングを作らないこと。
  - 例外的に特殊なアニメーション等が必要な場合はデザイナーと合意のうえ共通コンポーネントを拡張し、その拡張を全体に展開すること。
  - デバッグ用の一時的な console.log や個別のスピナーは `ALLOW_DEBUG_EXEC_LOGS` のフラグにより制御すること。

これにより、今後のローディングUIは `LoadingOverlay` を共通で利用してください。

---

## 変更時の原則

- どのブランチに上げるかを必ず明示。不明点は修正せず確認。  
- 既存ロジックを大きく変える提案は一度確認（互換影響の洗い出しを含む）。  
 - 外部APIや重要な取得処理の失敗時に**安易なフォールバックを追加して問題を隠蔽しないこと**。
   フォールバックを実装する場合は、事前に影響範囲と根本原因の確認を行い、設計書・PR に理由と代替案を明示してレビュワーの承認を得ること。
   重要な設定（例: AppConfig の読み込み等）は fail-fast を採用し、起動時・処理開始時に読み込めない場合は明確にエラーを返して停止する運用を優先する。
- 共通部品の変更は呼び出し元全体の動作確認をセット。  

---

## 定期実行（Lambda）ポリシー

- 対象語：`定期実行` / `自動投稿` / `scheduled` / `auto-post` / `lambda/scheduled-autosnsflow` を含む変更は Lambda 関連とみなす。  
- lambda ブランチにコミット/PR。コミットメッセージ・PR タイトルに `lambda:` を付与。  
- デプロイ前にローカル or ステージングで確認。main 反映は事前了承があるときのみ。  

---

## シークレット取り扱い

- APIキー/トークン/個人情報のコミット禁止。`.env.*` は `.gitignore`。  
- デプロイ時は GitHub Secrets / AWS Secrets Manager を使用。  
- CI に `git-secrets` / `truffleHog` を導入し、検出時はブロック。  
- 漏洩時は即ローテート＋履歴除去（`git filter-repo` 等）＋報告。  

---

## コマンド実行ポリシー

必須環境：**Windows PowerShell** を基本とする。  
原則：1 ステップ = 1 コマンド。ワンライナー連結（`&&`）禁止。  

### 1) 守護ランナーの使用
- `cx_run <job> <timeoutSec> "<cmd>"` で実行し、タイムアウト・ログ保存・未尾200行のみ表示を徹底。  
- 止まった時は `cx_stop <job>` を提示して強制停止できる形にする。  
- ログは `/tmp/cursor_guard/<job>_YYYYMMDD_HHMMSS.log`。  

### 2) Git 操作は非対話＋タイムアウト
- UNC パスを用い、必ず `-C` でリポジトリパスを明示する。  
- 例:  
  ```powershell
  git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" status
commit は必ず -m 指定。必要時のみ --no-verify。

操作前後で git status --porcelain を実行して確認。

認証は SSH 鍵前提。プロンプト待ち禁止。

3) 出力・ログの扱い
長い出力は必ずファイルへ（> /tmp/*.json / /tmp/*.log）。

JSON 確認は jq。画面は要点のみ表示。

4) 長い/複雑な処理
長文コマンドや here-doc は /tmp/*.sh に保存して実行。

各ステップで結果を確認してから次へ進む。

5) 例（ワンライナー禁止 → 分割推奨）
NG:

sh
コードをコピーする
git rm -r --cached A B && git commit -m "chore" && git push origin lambda
OK:

powershell
コードをコピーする
git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" rm -r --cached A B
git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" status --porcelain
git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" commit -m "chore: remove test artifacts" --no-verify
git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" push --porcelain --no-verify origin lambda
ビルド
powershell
コードをコピーする
cx_run build 1800 "npm ci"
cx_run build 1800 "npm run build"
cx_run lsout 30  "ls -lh .next | tail -n 50"
事故復旧
実行が進まない場合
cx_stop <job>

powershell
コードをコピーする
Get-ChildItem -Recurse .git\*.lock | Remove-Item -Force
git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" status --porcelain
端末不調時
Clear-Host でターミナルリセット

必要に応じて PowerShell 再起動

ビルド/マージ注意（CI 向け短縮版）
マージ競合マーカー（<<<<<<< / ======= / >>>>>>>）を残したまま push すると CI が失敗。必ず解消して確認。

解消後は明示的に git add → commit する（自動 commit 禁止）。

ローカルで npm run build または tsc を実行し構文・型チェックを通す。

push は原則 --force 禁止。必要なら --force-with-lease を使用。

DynamoDB の AttributeValue を直接返さない。必ず正規化。

---

## 追記: `deleteUserPosts` / 共通削除方針

- 目的: アカウント編集モーダル（即時削除）および定期実行（キュー処理）で同一の削除フローを実行するための共通方針を明文化する。
- 呼び出し先: `src/lib/delete-posts-for-account.ts`（新規共通関数 `deletePostsForAccount` を定義し、`delete-all` API と Lambda キュー処理の両方から呼び出す）。
- 入力:
  - `userId` (必須)
  - `accountId` (必須: スレッズアカウントを必ず指定すること)
  - `limit` (任意、既定値は AppConfig の `DELETION_BATCH_SIZE` または 100)

- 挙動（厳密手順、要件に準拠）:
  1. **取得フェーズ**: `fetchThreadsPosts({ userId, accountId, limit })` を実行して Threads 側の投稿IDを取得する。API 呼び出しが失敗した場合は即時に処理を中断し例外を投げる（0件取得とは明確に区別）。
  2. **削除フェーズ（API優先）**: 取得した各 `postId` に対して、**DBの有無に関わらず**必ず Threads DELETE API を呼び出す（`deleteThreadsPostWithToken` 等）。API 削除の成功判定は `src/pages/api/threads/delete-post.ts` と同一の基準を用いる（`resp.ok` または `json.success === true` を成功と見なす；404 や Facebook の `error_subcode===33` 等は "存在しない" 扱いとして成功として扱う）。
  3. **DB同期（API成功後）**: 外部DELETE が成功（または存在しない扱い）した場合のみ、その `postId` と `accountId` を用いて `ScheduledPosts` を照会し、該当レコードが存在する場合は **物理削除（DeleteItemCommand）** を行う。DBに該当がなければ何もしない。
  4. **完了判定**: 指定件数を処理した後、追加で1件のみ `fetchThreadsPosts(..., limit:1)` を再実行し、0件なら `remaining=false`（削除完了）とし、キューが存在する場合はキューの削除とアカウント `status` を `active` に戻す。残件がある場合は `remaining=true` として呼び出し元がキュー作成/継続を行う。

- エラーとログ方針:
  - **ExecutionLogs（永続化 via `putLog`）へ書き込むのは以下のみ**:
    - API 呼び出し（fetchThreadsPosts）で致命的エラーが発生し処理を中断した場合（`deletion_error`）。
    - 外部DELETE において致命的エラー（権限不足、token 欠落など）により処理を中断した場合（`deletion_error`）。
    - 削除が完了しアカウント `status` を更新した場合（`deletion_completed`）に要約を記録する（`deletedCount` を含む）。
  - それ以外の詳細ログ（取得結果の一覧、各DELETE のレスポンス、マッピングのサンプル等）はすべて `console.info/warn/error` を用いて CloudWatch に出力すること。外部通知（Discord 等）や大量のデバッグ出力は `ALLOW_DEBUG_EXEC_LOGS` フラグでガードすること。

- DB操作の順序に関する厳守点:
  - **DB レコードを参照してから外部DELETE を発行することはしない**。必ず Threads API に対して削除を試み、その後に DB を参照して該当レコードがあれば物理削除する（API → DB の順）。

- 戻り値: `{ deletedCount: number, remaining: boolean }`

- 実装上の補足:
  - 物理削除ユーティリティ `src/lib/scheduled-posts-delete.ts` は、キュー処理／即時処理のどちらから呼ばれても同一の振る舞いをするようにオプションで "物理削除時に失敗したら例外を throw して呼び出し元で再試行させる" 動作をサポートすること。
  - `deletePostsForAccount` は共通実装を提供し、`src/pages/api/accounts/[accountId]/delete-all.ts` の即時削除と `lambda/scheduled-autosnsflow/src/handler.ts` のキュー削除の両方から呼び出す。定期実行側は優先度に応じて段階的に切替える。


---

## 運用上の注意（将来的な最適化）

- 現状、`/api/threads-accounts` の実装では各アカウントについて DynamoDB の `GetItem` / `Query` を個別に実行して `status` を取得するフォールバック処理を採用しています。小規模環境では問題ありませんが、アカウント数やトラフィックが増加するとレイテンシとコストの問題が発生します。
- 将来的には以下のような一括取得・索引を検討して下さい:
  - `DeletionQueue` や `ThreadsAccounts` をまたいだ一括 `Query` を行うための GSI の導入（例: `userId` / `status` をキーとした GSI）。
  - `ThreadsAccounts` 側で `status` をまとめて返却するバックエンド側の集約処理（backend-core 側の拡張）。
  - `DeletionQueue` の存在チェックを一度のバッチ Query で取得し、フロント向けレスポンスにマージして返す設計。
- 上記の最適化はパフォーマンス向上とコスト削減に寄与します。スケールや運用コストの指標が閾値を超えたら優先的に対応してください。

---

ワークツリー全体をステージする操作 (git add -A) の注意
git add -A は未追跡ファイルも含めるため、個人環境ファイルや長いファイル名の混入リスクがある。

安全な手順:

git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" status --porcelain

不要ファイルは .gitignore へ追加

必要ファイルのみ git add <path> または git add -p

Windows 側で長いパスエラーが出る場合は .gitignore に追加するか、core.longpaths を有効化

powershell
コードをコピーする
git config --system core.longpaths true
追記: PowerShell 環境での Git 操作について
本プロジェクトは Windows + WSL の併用環境。PowerShell 側から UNC パスで WSL 内を指定する。

例:

powershell
コードをコピーする
git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" <command>
ステップ実行を徹底。&& 禁止。長い出力はログへ保存して確認。

推奨ワークフロー（commit → staging push）
git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" add <files...>

git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" commit -m "<msg>"

git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" checkout staging（なければ checkout -b staging）

git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" merge --no-edit main

git -C "\\wsl.localhost\Ubuntu\home\revival\projects\AutoSNSFlow\frontend" push origin staging

---

## テスト方針（実データによる手動検証）

- 方針: モックは使わず、実運用データを用いて手動で検証を行います。まずは削除処理（即時/キュー/キューからの定期実行）を小さいバッチで確認し、その後本番想定のケースで最終チェックを行います。

- 対象ケース:
  - アカウントA: 投稿合計が 100 件以下のアカウント（全件一括削除が完了することを確認）
  - アカウントB: 投稿合計が 100 件を超えるアカウント（複数バッチに分割されることを確認）

- 検証手順（段階的）:
  1. バッチサイズをテスト用に小さく設定（例: 10 件）する。
  2. UI の「即時削除(バッチ)」で 10 件削除を実行し、API の応答と UI の反映（削除件数・残件表示・ExecutionLogs）を確認する。
  3. UI の「裏画面実行(キュー化)」でキューを作成し、`DeletionQueue` テーブルにエントリが作成されることを確認する。
  4. 定期ワーカー（または手動でワーカー処理をトリガー）を実行して、キューから削除処理が実行されることを確認する（各バッチで 10 件ずつ削除されることを期待）。
  5. すべて削除されたら、`DeletionQueue` の該当エントリが削除され、アカウントの `status` が `active` に戻ることを確認する。

- 本番想定の最終チェック:
  - 上記の基本検証が通ったら、バッチサイズを 100 に戻し、
    - アカウントA(<=100) で全削除が一回で完了すること、
    - アカウントB(>100) で複数バッチに分かれて最終的に全削除されることを確認する。

- 注意事項:
  - 実データを用いるため、事前にバックアップや復旧手順を必ず確認してください。
  - テスト中は自動投稿を抑止（アカウントの `status = 'deleting'`）しておくこと。
  - バッチサイズを小さくすると削除に時間がかかるため、実施時間を運用チームと調整してください。

- 優先度: 高（まずは定期実行ワーカーの見直しを優先し、その後上記の手順で検証を実行）

---

## ルールと実装の差分 / 不足点（要追記・検討）

- 現状の実装は `ScheduledPosts` テーブル上の `status === 'posted'` かつ `isDeleted !== true` を主な削除対象としている。一方でルールでは「API で存在する全ての投稿（ScheduledPosts に登録されていない投稿も含む）を削除する」とあるため、両者のカバレッジにズレがある。
- 即時実行の dry-run（count）は Threads API を参照するが、実削除は DB ベースの抽出を優先しているため、取得件数と実削除対象の不一致が発生しうる。
- Lambda のキュー処理は現在 `Scan` による全テーブル走査で due 項目を検出している。スケール時のパフォーマンスとコスト観点で GSI / Query ベースへの移行が必要。
- エラー時の運用方針がルールと実装で一部食い違う（ルールは「停止して手動対応を期待」するケースがあるが、実装は retry_count を使って再試行可能にしている）。どちらに統一するか決定が必要。

## 追加で必要と考えられる処理・改善案（要検討）

- Threads API にのみ存在する投稿も削除対象とするため、キュー処理または即時削除で Threads API からの取得→削除を行えるようにする（ScheduledPosts との突合せルールを規定）。
- `ExecutionLogs` のスキーマを明確化してログ出力を統一するラッパー関数を導入する（必須フィールド: userId, accountId, action, status, message, deletedCount, errorDetail, initiatedBy, timestamp）。
- 失敗時の挙動を明文化（自動再試行の最大回数・指数バックオフ・最終的に status を `deletion_error` に設定して管理者通知を行う等）。
- DeletionQueue の検索を `Scan` から GSI/Query ベースへ移行。具体的には `userId` 或いは `status` をキーとした GSI の追加を検討する。
- バッチサイズを環境変数または ThreadsAccounts のメタフィールドで可変にし、テスト時や緊急対応時に切り替えられる仕組みを追加する。
- 権限エラー（401/403）や RateLimit に対する明確な制御（通知、アカウント停止、エラーステータス設定）を追加。
- キュー項目に TTL や最大 retry 上限を追加し、長期放置や永久失敗時の自動通知を行う。
- 削除処理の idempotency を改善（同じ投稿に対する重複削除呼び出し時の安全性）。

## ルールに無いが必要と感じる項目（要検討）

- 削除対象の総合定義（ScheduledPosts と Threads API 双方をどのように統合して“全投稿”と見なすか）をルールへ追記する必要。
- IAM ポリシーの最小権限定義を Lambda / 管理 UI / バッチ処理ごとに明確化するドキュメント。
- 操作ログに `initiatedBy`（ユーザーまたはシステムの識別子）を必須化し、監査トレイルを強化すること。
- キュー監視用のアラート（CloudWatch / Slack / Discord）やダッシュボードを整備すること。

---

注: 上記はすべて「要検討」項目です。優先順位と採用方針を決めたあと、具体的な実装タスク（ファイル/コード差分）を作成します。

## デバッグ出力ポリシー

- 目的: 本番環境へ無秩序なデバッグ出力や外部通知を残さず、調査時のみ安全に出力を許可するためのガイドライン。

- 基本原則:
  - 本番での恒常的な外部Webhook直打ちや大量のconsole出力を禁止する。
  - 調査目的で一時的に外部通知を行う場合は、必ず `ALLOW_DEBUG_EXEC_LOGS`（値 `'true'` または `'1'`）で有効化すること。
  - シークレット（accessToken, clientSecret 等）は決して出力してはならない。出力が必要な場合はマスクして記録する。

- 実装ルール:
  1. 外部通知（Discord/Slack等）や詳細な診断は `if (process.env.ALLOW_DEBUG_EXEC_LOGS === 'true' || process.env.ALLOW_DEBUG_EXEC_LOGS === '1')` でガードすること。
  2. 永続的な調査記録は `ExecutionLogs`（`putLog`）へ構造化して保存し、外部通知は運用アラート経路で別途送信すること。
  3. デバッグコードを追加する際は PR に明記し、レビューで必ず削除またはフラグ制御されていることを確認すること。
  4. デバッグ有効化は運用者のみが切り替えられるよう権限を制限すること（IAM ポリシーで制御）。

- 運用注意:
  - デバッグを有効にしたまま本番で長期間放置しない。必ず作業後に `ALLOW_DEBUG_EXEC_LOGS` を無効化する。
  - 外部通知はレート制御やサンプリングを行い、運用サービスへの負荷・スパムを防ぐこと。

## ローカルでのビルド検証（推奨コマンド）

- WSL 上でビルドと型チェックを実行する際は、必ずプロジェクトの frontend ディレクトリで次のコマンドを実行してください:

  ```powershell
  wsl -d Ubuntu -u revival bash -lc "cd /home/revival/projects/AutoSNSFlow/frontend && npm run build"
  ```

  - 実行前に `npm ci` を行い、`.env.local` 等の環境変数を準備してください。
  - ビルド失敗時は出力ログを保存して原因を特定し、修正後に再実行してください。

