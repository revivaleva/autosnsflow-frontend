# pjspec: 自動投稿の選択と再試行仕様

この仕様書は、定期実行（every-5min）における予約投稿の選択・投稿・再試行の挙動を定義する。現在実装中（development）であり、リリース前にレビューとテストが必要。

## 目的
- 引用投稿が引用元の削除等で失敗して投稿処理が停止する事象を防ぐ
- 前回失敗した古い引用投稿よりも、新しい引用投稿を優先して投稿する
- 引用・通常投稿それぞれ1件ずつを同一5分実行内で最大1回ずつ投稿する
- 投稿処理でエラーが発生しても次の候補への処理を継続する
- 投稿に失敗した予約はメタデータを記録し、UIで失敗が視認できるようにする

## 主要ルール
1. 1アカウント当たりの投稿回数
   - every-5min の `runAutoPostForAccount` は、1回の実行で最大で「引用投稿 1 件」＋「通常投稿 1 件」を試行する（合計最大2件）。

2. 候補選出
   - GSI から候補を取得後、候補をタイプ別（quote / normal）に分離し、それぞれ古い順にソートして処理する。
   - ただし、`postAttempts` がある候補は優先度を下げ、まず `postAttempts === 0` のものを試行する。

3. 再試行と失敗メタ
   - 投稿失敗時に、該当予約レコードへ `postAttempts`（数値）をインクリメントし、`lastPostError`（短いエラーメッセージ）、`lastPostAttemptAt`（unix秒）を保存する。
   - 明らかに永久的なエラー（例: 引用元が削除されていると判定できる場合）は `permanentFailure=true` を付与し、次回以降はスキップされる。
   - `postAttempts >= 3` の場合は優先度を大幅に下げる（デフォルトでスキップ候補）。

4. エラー耐性
   - 各候補の投稿処理は個別に try/catch し、失敗はその候補のメタへ記録して処理を継続する。アカウント全体のループは続行する。

5. UI 表示
   - `ScheduledPostsTable` は `postAttempts > 0` や `lastPostError` がある予約行を強調表示（背景色変更）する。

## 開発中の注記
- 現在の実装ブランチ: `lambda`（ローカルで確認済み）
- 影響が大きい箇所のため、採用前に以下を実施する:
  - 単体テスト/統合テスト
  - DynamoDB の既存データに対する互換性確認
  - デプロイ前の Canary 実行

## TODO（実装タスク）
- T001 - T009 を参照（`pjtodo.mdc` に記載）

## 変更履歴（短縮）
- 2025-10-27: X自動投稿の候補取得を `GSI_ByAccount` → クライアント側フィルタのフローに変更（Threads と整合）
- 2025-10-27: 即時投稿後に `pendingForAutoPostAccount` を `REMOVE` するよう API を修正
- 2025-10-27: 1実行内で同一 X アカウントへ複数投稿されないようガードを追加
- 2025-10-27: デバッグ向けの冗長ログは最小化（本番向けログ量削減）

- PRUNE: daily-prune の全表 Scan→削除への変更（dry-run フラグ付き、DeletionQueue 中アカウントを除外）
- PRUNE: UsageCounters を updatedAt で全表削除（BatchWriteItem を使用）
- PRUNE: Discord 通知を各テーブル毎の削除件数/全件数表示へ変更（実行時間含む）

## 関連ファイル
- `lambda/scheduled-autosnsflow/src/handler.ts`
- `src/app/scheduled-posts/ScheduledPostsTable.tsx`

## dry-run / テスト実行の伝搬仕様（追加）
この節は、Lambda ハンドラに渡された `event.dryRun` を各処理に明示的に伝搬し、ドライラン時にデータベースへの副作用（予約レコード作成 / プール消費 / 物理削除）を抑止して件数のみを集計・通知するための仕様を定義する。

- Handler レベル
  - `handler(event)` は `event.dryRun === true` を受け取った場合、`runHourlyJobForUser` / `runFiveMinJobForUser` / `processDeletionQueueForUser` に `opts = { dryRun: true }` を渡すこと。
  - 既存の `testInvocation` / `detailedDebug` フラグとは独立して動作すること。

- ユーザー単位ラッパー
  - `runHourlyJobForUser(userId, opts)` / `runFiveMinJobForUser(userId, opts)` を導入し、内部呼び出し（`ensureNextDayAutoPosts`、`ensureNextDayAutoPostsForX`、`createQuoteReservationForAccount` など）へ `opts` をそのまま伝搬すること。
  - 各内部処理は `opts.dryRun === true` を受け取ったら「DB 書き込みを行わず、件数や候補情報を `TEST_OUTPUT` / Discord 用の集計値として記録する」こと。

- 具体的な DB 副作用の扱い
  - 予約レコード作成（`createScheduledPost` / `createQuoteReservationForAccount` 等）: `opts.dryRun === true` の場合は PutItem を実行せず、作成予定のデータ（accountId, whenJst, group 等）を `TEST_OUTPUT` に `DRYRUN_CREATE_SCHEDULED_POST` / `DRYRUN_CREATE_QUOTE_RESERVATION` タグで出力し、呼び出し元へは作成カウントを返す。
  - プール消費 / 即時投稿（`postFromPoolForAccount`）:
    - dry-run 時は既に `opts.dryRun` を受け付け、プールロックの獲得や DB 更新（DeleteItem/UpdateItem）を行わず、候補の情報を `TEST_OUTPUT` に `DRYRUN_POST_FROM_POOL` タグで出力すること。ロック取得は行わない。
    - プールからアイテムを取得した場合は、実行結果に関係なく `XScheduledPosts`（`TBL_X_SCHEDULED`）へ記録し、UI の予約一覧に反映すること。実装方針:
      - プール項目のロック取得後（dry-run では除外）に `XScheduledPosts` に `status='attempting'` の項目を作成する。`scheduledPostId` は `xsp-pool-<poolId>-<unix>` 形式とする。  
      - 投稿成功時は該当 `XScheduledPosts` を `status='posted'` に更新し `postedAt`/`postId` を設定する。プール項目は削除する。  
      - 投稿失敗時は該当 `XScheduledPosts` を `status='failed'` に更新し `lastPostError` を保存、プール項目はロック解除して残す（再試行可能）。  
      - dry-run 実行時は `XScheduledPosts` の作成・更新は行わない（`DRYRUN_POST_FROM_POOL` のみ出力）。
  - 削除処理（`processDeletionQueueForUser` / `deleteUpTo100PostsForAccount` / `deletePostedForUser` 等）: dry-run 時は実際の DeleteItem を行わず、`countPostedCandidates` 等を用いて削除候補数を算出し、その件数を集計に加える。Queue の取り消しや account 状態の更新は行わない。

- 通知
  - dry-run 実行時でも Discord へのサマリ送信は行うが、送信内容は「実行予定件数」や「削除予定件数」などの推定値に限定し、実際の作成 IDs / postId は含めない。

- 互換性と安全性
  - `opts` の未指定時は既存の挙動（実行）を維持する。`global.__TEST_CAPTURE__` との互換性を保ちつつ、明示的な `opts.dryRun` を優先して扱う。
  - dry-run の判定は明示的で単純に保ち、誤って本番データを書き換えないために Put/Delete の直前でガードを行う。

（追記済み: 実装は `lambda/scheduled-autosnsflow/src/handler.ts` に反映済み）


(作成日: development)

## 管理画面（Admin Users）仕様

### 目的
- サービス管理者がユーザー単位で利用制限や表示名を管理できるようにする。
- 不正利用や運用上の設定変更を容易に行える管理UIを提供する。

### 主な機能
1. **認可**: 既存の Cognito の管理者グループ（`env.ADMIN_GROUP`, デフォルト `Admins`）のメンバーのみアクセス可能。
2. **ユーザー一覧表示**: 各ユーザーの以下情報を一覧で表示する。
   - email
   - userId (Cognito sub)
   - username (管理用表示名、管理画面のみで保存・編集)
   - planType
   - apiUsedCount / apiDailyLimit
   - maxThreadsAccounts（ユーザーが登録できる Threads アカウント数、デフォルト 0）
   - autoPost, autoPostAdminStop
   - updatedAt
3. **編集モーダル**: 各ユーザーの `username`、`apiDailyLimit`、`maxThreadsAccounts`、`autoPost`、`autoPostAdminStop` を編集し保存できる。
4. **コピー可能な userId 表示**: ログイン後のメニューバー下に userId を表示し、クリックでクリップボードへコピーできる。

### データ設計（UserSettings テーブル）
- 既存の `UserSettings` レコードに以下フィールドを追加:
  - `username`: S (デフォルト: "")
  - `maxThreadsAccounts`: N (デフォルト: "0")

### API 仕様
- `GET /api/admin/users` : Cognito からユーザー一覧を取得し、DynamoDB の UserSettings を結合して返却。
- `PATCH /api/admin/users` : 管理者権限で `username`, `apiDailyLimit`, `maxThreadsAccounts`, `autoPost`, `autoPostAdminStop` を更新。

### セキュリティ/運用
- 管理APIは必ず `verifyUserFromRequest` を経由して `assertAdmin` を実行すること。
- 管理操作の監査ログは現時点では不要（将来の拡張で DynamoDB に記録可能）。

### リスクと対応
- DynamoDB の既存レコードにフィールドがない場合は GET 時に初期化（デフォルト値挿入）して互換性を保つ。

## License Token 管理・認証仕様

### 概要
コンテナブラウザに対して License Token ベースの認証と利用制限（コンテナ登録数上限）を提供する。トークンは 1 PC に対して 1 対 1 でバインドされ、PC 側で管理画面から検証・管理できる。

### データモデル

#### Token 1 つ = PC 1 台
- 同時に複数 PC で使用不可
- `bound_device_id` で現在バインド中の PC を管理

#### Remaining Quota
- PC 上のコンテナブラウザで作成可能なコンテナ（ブラウザプロファイル）の個数上限
- 管理画面の「編集」でのみ管理者が変更可能
- コンテナ作成・削除時に API が変更することはない

#### 新フィールド: コンテナ数トラッキング
- `current_container_count`: 現在使用中のコンテナ数（PC から報告）
- `container_count_updated_at`: コンテナ数の最終更新時刻

### API 仕様

#### Validate エンドポイント
```
POST {AUTH_API_ENDPOINT}/auth/validate
Authorization: Bearer {license_token}
Content-Type: application/json

Request:
{
  "device_id": "PC-device-identifier",
  "device_info": { /* optional */ },
  "current_container_count": 5  // ✅ 追加（オプション）
}

Response (200):
{
  "ok": true,
  "code": "OK",
  "data": {
    "token": "...",
    "remaining_quota": 100,              // コンテナ作成可能数（上限）
    "current_container_count": 5,        // ✅ 追加: 現在のコンテナ数
    "expires_at": 1735689600,
    "bound": true,
    "session_expires_at": 1735732800
  }
}
```

**エラーコード**:
- `400 BAD_REQUEST`: token/device_id 未指定
- `401 INVALID_TOKEN`: トークン未発見
- `410 TOKEN_EXPIRED`: トークン有効期限切れ
- `423 TOKEN_DISABLED`: トークン無効化済み
- `403 BOUND_TO_OTHER`: 別 PC でバインド済み（「再統込」が必要）

#### Heartbeat エンドポイント
```
POST {AUTH_API_ENDPOINT}/auth/heartbeat
Authorization: Bearer {license_token}
Content-Type: application/json

Request:
{
  "device_id": "PC-device-identifier",
  "current_container_count": 5  // ✅ 追加（オプション）
}

Response (200):
{
  "ok": true,
  "code": "OK",
  "data": {
    "token": "...",
    "remaining_quota": 100,
    "current_container_count": 5,  // ✅ 追加: 現在のコンテナ数
    "session_expires_at": 1735732800
  }
}
```

### クライアント実装フロー

#### 初回起動
1. license_token を取得
2. device_id を取得（Windows: MachineGuid など）
3. ローカルのコンテナ数をカウント
4. `POST /auth/validate` を呼び出し → remaining_quota, current_container_count を取得
5. 管理画面を表示（制限数をもとにコンテナ作成制限を適用）

#### コンテナ作成時
1. アプリ内の remaining_quota を参照
2. 判定: `if (currentContainers >= remaining_quota) { showError(...) }`
3. コンテナ作成許可 → 次の heartbeat で数を更新

#### 定期ハートビート（30 分ごと）
1. ローカルのコンテナ数をカウント
2. `POST /auth/heartbeat` を呼び出し → session_expires_at を延長
3. current_container_count をサーバーに報告（同期）

### 管理画面（Token 管理）

#### トークン一覧テーブル
新カラム追加:
- 「使用中コンテナ数」: current_container_count フィールドの値

#### トークン詳細表示
```
トークン情報
├─ Token ID
├─ Username
├─ 有効期限
└─ 状態

使用状況
├─ 作成可能: remaining_quota
├─ 使用中: current_container_count  ✅ 追加
├─ 残数: remaining_quota - current_container_count
└─ 最終更新: container_count_updated_at

PC バインディング
├─ デバイスID
├─ バインド日時
└─ 再統込ボタン
```

#### 編集ダイアログ
- Username, remaining_quota, expires_at, disabled は編集可能
- current_container_count は自動同期のため編集不可

### DB スキーマ（LicenseTokens テーブル）
- `token_id` (PK, String)
- `username` (String, optional)
- `remaining_quota` (Number) - 作成可能な上限
- `current_container_count` (Number) ✅ 追加 - 現在のコンテナ数
- `container_count_updated_at` (Number) ✅ 追加 - コンテナ数の更新時刻
- `expires_at` (Number)
- `disabled` (Boolean)
- `bound_device_id` (String, optional)
- `bound_at` (Number, optional)
- `session_expires_at` (Number, optional)
- `updated_at` (Number)